#!/usr/bin/env node

'use strict';

var path = require('path'),
	spawn = require('child_process').spawn,
	fs = require('fs');


var packageJson = require(path.join(process.cwd(), 'package.json')),
	scripts = packageJson.scripts,
	isWin = process.platform.substring(0, 3) === 'win';

var scriptArgs = process.argv.slice(2);

function exit(code) {
	function done() {
		if (!(draining--)) {
			process.exit(code);
		}
	}

	var draining = 0;
	var streams = [process.stdout, process.stderr];

	streams.forEach(function(stream){
		draining += 1;
		stream.write('', done);
	});

	done();
}

function extend(dst, src) {
	for (var key in src) {
		dst[key] = src[key];
	}
	return dst;
}

function findEnvVarName(env, names) {
	for (var index in names) {
		if (names[index] in env) return names[index];
	}
}

function addArgumentsToScript(script, args) {
	if (args.length) {
		script = script + ' ' + args.map(function(arg) {
			if (isWin) {
				return '"' + arg.replace(/(\\*)"/g, '$1$1\\"')
					.replace(/(\\*)$/, '$1$1') + '"';
			} else {
				return '"' + arg.replace(/"/g, '\\"') + '"';
			}
		}).join(' ');
	}

	return script;
}

function runSingleScript(scriptName, script, callback) {
	console.log('> nrun %s', scriptName);
	console.log('> %s', script);

	var cmd, args;
	var spawnOpts = {
		stdio: 'inherit',
		env: extend({}, process.env)
	};

	// add binaries to path
	var pathVarName = findEnvVarName(process.env, ['PATH', 'Path', 'path']);
	spawnOpts.env[pathVarName] += path.delimiter +
		path.resolve('node_modules', '.bin');

	if (isWin) {
		cmd = process.env.comspec || 'cmd';
		args = ['/s', '/c', '"' + script + '"'];
		spawnOpts.windowsVerbatimArguments = true;
	} else {
		cmd = process.env.SHELL || '/bin/sh';
		args = ['-c', script];
	}

	spawn(cmd, args, spawnOpts)
		.on('close', callback);
}

function runScript(scriptName, callback) {
	var preScriptName = 'pre' + scriptName,
		postScriptName = 'post' + scriptName,
		scriptsToRun = [];

	if (scripts[preScriptName]) {
		scriptsToRun.push({
			scriptName: preScriptName,
			args: []
		});
	}

	scriptsToRun.push({
		scriptName: scriptName,
		args: scriptArgs
	});

	if (scripts[postScriptName]) {
		scriptsToRun.push({
			scriptName: postScriptName,
			args: []
		});
	}

	function run(index) {
		var item = scriptsToRun[index],
			scriptName = item.scriptName,
			args = item.args,
			script = scripts[scriptName];

		runSingleScript(
			scriptName,
			addArgumentsToScript(script, args),
			function(code) {
				if (code || index === scriptsToRun.length - 1) {
					return callback(code);
				}

				console.log('');
				run(index + 1);
			}
		);
	}

	run(0);
}

if (!scriptArgs.length) {
	console.log('Scripts for "%s":', packageJson.name);
	Object.keys(scripts).forEach(function(scriptName) {
		console.log('  %s', scriptName);
		console.log('    %s', scripts[scriptName]);
	});
	return exit(0);
}

if (scriptArgs.indexOf('--completion') >= 0) {
	console.log(
		fs.readFileSync(path.join(__dirname, 'completion.sh'), 'utf8')
	);
	return exit(0);
}

var scriptName = scriptArgs.shift();

if (scriptName in scripts === false) {
	console.error(
		'Unknown script "%s" for package "%s"',
		scriptName, packageJson.name
	);
	return exit(1);
}

runScript(scriptName, exit);
